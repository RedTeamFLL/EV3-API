/** \file ev3_button.lejos.c
 * \brief Frontend implementation of the leJOS button API
 *
 * License:
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/
 *
 * The Initial Developer of this code is Jakub Vanek.
 * Portions  by Jakub Vanek are Copyright (C) 2020 Jakub Vanek.
 * All Rights Reserved.
 *
 * ----------------------------------------------------------------------------
 *
 * \author Jakub Vanek
 * \date 2020-02-12
 * \version 1
 */

#include "ev3.h"

////////////////////////////////////////////////////////////////////////////////
// MACROS

//! Time to wait in leJOS functions for debouncing
#define BUTTON_WAIT_DEBOUNCE 10 // msec

////////////////////////////////////////////////////////////////////////////////
// PRIVATE DECLARATIONS

/*!
 * Detects whether a requested event has occured.
 */
typedef bool (*ButtonDetector)(ButtonMask oldBits, ButtonMask newBits);

/*!
 * Summarizes an event to a button bitmask.
 */
typedef unsigned int (*ButtonSummarizer)(ButtonMask oldBits, ButtonMask newBits);

/*!
 * \brief Sample current kernel state of buttons into a bitmask.
 * \param mask leJOS bitmask of pressed buttons.
 * \return Whether the sampling succeeded.
 */
static bool btnSampleBits(ButtonMask *mask);

/*!
 * \brief Spin until kernel buffer contains given value for given button.
 * \param btn Button to wait on.
 * \param isPressed Value to wait for.
 * \return Whether the operation succeeded or not.
 */
static bool btnWaitForKernelState(Button btn, bool isPressed);

/*!
 * \brief Detect any button press or release.
 * \param oldBits Old button bitmask.
 * \param newBits New button bitmask.
 * \return Whether a button press or release occured.
 */
static bool btnDetectAny(ButtonMask oldBits, ButtonMask newBits);

/*!
 * \brief Detect any button press.
 * \param oldBits Old button bitmask.
 * \param newBits New button bitmask.
 * \return Whether a button press occured.
 */
static bool btnDetectPress(ButtonMask oldBits, ButtonMask newBits);

/*!
 * \brief Summarize pressed & released events into a bitmask.
 * \param oldBits Old button bitmask.
 * \param newBits New button bitmask.
 * \return Bitmask of newly pressed or released buttons.
 */
static unsigned int btnSummarizeAny(ButtonMask oldBits, ButtonMask newBits);

/*!
 * \brief Summarize pressed buttons into a bitmask.
 * \param oldBits Old button bitmask.
 * \param newBits New button bitmask.
 * \return Bitmask of newly pressed buttons.
 */
static unsigned int btnSummarizePress(ButtonMask oldBits, ButtonMask newBits);

/*!
 * \brief Wait for a button event to occur.
 * \param timeout Timeout in milliseconds.
 * \param detect Detector function to stop the wait.
 * \param resolve Summarizing function to generate a return value.
 * \return Value generated by the summarizing function after the detector has passed; or zero if timeout has elapsed.
 */
static unsigned int btnWaitForEvent(unsigned int timeout, ButtonDetector detect, ButtonSummarizer resolve);

////////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION


// state query
bool ButtonIsUp(Button index)
{
    return !ButtonIsDown(index);
}

bool ButtonIsDown(Button index)
{
    int result = ButtonCoreReadButton(index);
    return result == -1 ? false : result != 0;
}

// wait-for-any

unsigned int ButtonWaitForAnyEvent(unsigned int timeout)
{
    return btnWaitForEvent(timeout, &btnDetectAny, &btnSummarizeAny);
}

unsigned int ButtonWaitForAnyPress(unsigned int timeout)
{
    return btnWaitForEvent(timeout, &btnDetectPress, &btnSummarizePress);
}

unsigned int btnWaitForEvent(unsigned int timeout, ButtonDetector detect, ButtonSummarizer resolve)
{
    unsigned long dstTimestamp = timeout == 0 ? ULONG_MAX
                                            : TimerWait(timeout);

    ButtonMask lastBits = 0;
    if (!btnSampleBits(&lastBits)) return 0;

    ButtonMask newBits = 0;
    while (true)
    {
        if (dstTimestamp > TimerGetMS())
            Wait(BUTTON_WAIT_DEBOUNCE);
        else
            return 0;

        ButtonMask tmpBits = 0;
        if (!btnSampleBits(&tmpBits)) return 0;

        if (newBits != tmpBits)
        {
            newBits = tmpBits;
            continue;
        }

        if (detect(lastBits, newBits))
            return resolve(lastBits, newBits);
        else
            lastBits = newBits;
    }
}

bool btnSampleBits(ButtonMask *pBits)
{
    uint8_t pressed[NUM_BUTTONS];
    if (!ButtonCoreReadButtons(pressed))
        return false;

    for (unsigned int btn = 0; btn < NUM_BUTTONS; btn++)
    {
        if (pressed[btn] != 0)
            *pBits |= BUTTON_MASK_OF(btn);
    }
    return true;
}

bool btnDetectAny(ButtonMask oldBits, ButtonMask newBits)
{
    return oldBits != newBits;
}

bool btnDetectPress(ButtonMask oldBits, ButtonMask newBits)
{
    return (newBits & ~oldBits) != 0;
}

unsigned int btnSummarizeAny(ButtonMask oldBits, ButtonMask newBits)
{
    ButtonMask pressed = newBits & ~oldBits;
    ButtonMask releasd = oldBits & ~newBits;
    return EVENT_MASK_MAKE(pressed, releasd);
}

unsigned int btnSummarizePress(ButtonMask oldBits, ButtonMask newBits)
{
    return EVENT_MASK_MAKE(newBits & ~oldBits, 0);
}

// wait-for-one

bool ButtonWaitForPress(Button btn)
{
    if (btn < 0 || btn >= NUM_BUTTONS)
        return false;

    if (!btnWaitForKernelState(btn, 0))
        return false;
    if (!btnWaitForKernelState(btn, 1))
        return false;
    return true;
}

bool ButtonWaitForPressAndRelease(Button btn)
{
    if (btn < 0 || btn >= NUM_BUTTONS)
        return false;

    if (!btnWaitForKernelState(btn, 0))
        return false;
    if (!btnWaitForKernelState(btn, 1))
        return false;
    if (!btnWaitForKernelState(btn, 0))
        return false;
    return true;
}

bool btnWaitForKernelState(Button btn, bool isPressed)
{
    int state = ButtonCoreReadButton(btn);
    if (state == -1)
        return false;
    else if (state == isPressed)
        return true;

    while (true)
    {
        for(;;)
        {
            state = ButtonCoreReadButton(btn);
            if (state == -1)
                return false;
            else if (state == isPressed)
                break;
            else
                Wait(1);
        }

        Wait(BUTTON_WAIT_DEBOUNCE);

        state = ButtonCoreReadButton(btn);
        if (state == -1)
            return false;
        else if (state == isPressed)
            return true;
        else
            continue;
    }
}
